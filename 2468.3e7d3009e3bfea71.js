"use strict";(self.webpackChunkapp=self.webpackChunkapp||[]).push([[2468],{2468:(s,n,i)=>{i.d(n,{D:()=>r});var o=i(8256);let r=(()=>{class e{constructor(){this.exercises=[{id:0,name:"Jan-Feb 2017 Subject No. 1",index:"Problem 1",question:"Write a parallel (distributed or local, at your choice) program for solving the c-coloring problem. That is, you are given a number k, and n objects and some pairs umong them that have to have distinct colors. Find n solution to color them with at most & colors in total, if one exist. Assume you have a function that gets a vector with k integers epresenting the assingment of colors to objects and checks if the constraints are obeyed or not.",answer:'\n      #include <mpi.h>\n      #include <vector>\n      using namespace std;\n      \n      bool check_constraints(vector<int> colors) {\n          // Check if the constraints are obeyed\n          // ...\n      }\n      \n      int main(int argc, char* argv[]) {\n          int rank, size;\n          MPI_Init(&argc, &argv);\n          MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n          MPI_Comm_size(MPI_COMM_WORLD, &size);\n      \n          int k = atoi(argv[1]);\n          int n = atoi(argv[2]);\n      \n          // Divide the search space among processes\n          int chunk_size = (int) pow(k, n) / size;\n          int start = rank * chunk_size;\n          int end = (rank + 1) * chunk_size;\n      \n          // Try all possible color assignments\n          for (int i = start; i < end; i++) {\n              vector<int> colors(n);\n              int temp = i;\n              for (int j = 0; j < n; j++) {\n                  colors[j] = temp % k;\n                  temp /= k;\n              }\n              if (check_constraints(colors)) {\n                  // Send the solution to rank 0\n                  MPI_Send(&colors[0], n, MPI_INT, 0, 0, MPI_COMM_WORLD);\n                  break;\n              }\n          }\n      \n          if (rank == 0) {\n              // Receive solutions from other processes\n              vector<vector<int>> solutions;\n              for (int i = 1; i < size; i++) {\n                  vector<int> colors(n);\n                  MPI_Recv(&colors[0], n, MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n                  solutions.push_back(colors);\n              }\n              // Print the solutions\n              for (auto colors : solutions) {\n                  for (int color : colors) {\n                      cout << color << " ";\n                  }\n                  cout << endl;\n              }\n          }\n      \n          MPI_Finalize();\n          return 0;\n      }\n      ',read:!1},{id:1,name:"Jan-Feb 2017 Subject No. 1",index:"Problem 2",question:"Consider the following code for inserting a new value into a linked list at a given position. We assume that insertions can be called concurrently, but not for the same position. Find and fix the concurrency issue. \n      Also, describe a function for parsing the linked list.",answer:"\n      struct Node {\n        unsigned payload;\n        Node next;\n        Node prev:\n        mutex atx;\n      }\n\n      void insertAfter (Node before, unsigned value) {\n      Node* node = new Node;\n      node->payload= value;\n      Node* after =  before->next; \n      before->mtx.lock(); \n      before->next = node;\n      before->mtx.unlock();\n      after-mtx.lock();\n      after->prev = node;\n      after-mtx.unlock();\n      node->prev  = before;\n      node->next = after;\n\n        Answer: \n\n        The concurrency issue in this code is that it does not properly synchronize access to the linked list. Specifically, there is a race condition between the two threads\n        that are trying to insert new nodes into the list at different positions. One thread may be modifying the 'next' pointer of a node while another thread is trying to\n        access the 'prev' pointer of that same node, resulting in undefined behavior.\n\n        One way to fix this issue would be to use a global lock that is acquired before calling the insertAfter() function and released after the insertion is complete. This would\n        ensure that only one thread can access the linked list at a time, preventing any race conditions.\n\n        Another solution would be to use a lock-free data structure such as a lock-free linked list, which allows for concurrent access to the list without the need for locks.\n        A function for parsing the linked list could look like this:\n\n        void parseList(Node* head) {\n          Node* current = head;\n          while(current != nullptr) {\n            cout << current->payload << endl;\n            current = current-> next;\n          }\n        }\n\n        This function takes the head of the linked list as an input and iterates through the list by following the 'next' pointers of each node. It prints the payload of each node\n        as it goes along. This function is not thread-safe, so you need to make sure to synchronize the access to the linked list if the function is called concurrently.\n      ",read:!1},{id:2,name:"Jan-Feb 2017 Subject No. 1",index:"Problem 3",question:"We have n servers that can communicate to each other. There are events producing on each of them; each event has an associated information. Each server must write a history of all events (server and event inio) produced on all servers, and, furthermore, the recorded history must be the same for all servers. Write a distributed algorithm that accomplishes that. Consider the case n = 2 for starting.",answer:'\n      One way to accomplish this would be to be use a distributed consensus algorithm such as Paxos or Raft. The basic idea is that each server would act as a leader in a round-robin\n      fashion, and would propose new events to the other servers. The other servers would then vote on whether to accept the proposed events, and once a majority of servers have accepted\n      the proposed events, they would be added to the history. We can implement this algorithm by using the MPI Library in C++.\n\n      #include <mpi.h>\n      #include <vector>\n\n      struct Event {\n        int server_id;\n        std::string event_info;\n      }\n\n      std::vector<Event> event_history;\n\n      void record_event(int server_id, std::string event_info) {\n        Event new_event = {server_id, event_info};\n        event_history.push_back(new_event);\n      }\n\n      int main(int argc, char** argv) {\n        MPI_Init(&argc, &argv);\n\n        int world_size, world_rank;\n        MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n        MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n        while(true) {\n          // Wait for events to happen\n          // ...\n\n          // Record the event on the local history\n          record_event(world_rank, "Event information");\n          for (int i=0; i<world_size; i++) {\n            if (i != world_rank) {\n              MPI_Send(&world_rank, 1, MPI_INT, i, 0, MPI_COMM_WORLD);\n              MPI_Send("Event information", 17, MPI_CHAR, i, 0, MPI_COMM_WORLD);\n            }\n          }\n\n          // Recieve events from the other servers\n          for (int i=0; i < world_size - 1; i++) {\n            int server_id;\n            MPI_Recv(&server_id, 1, MPI_INT, MPI_ANY_SOURCE, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            char event_info[17];\n            MPI_Recv(event_info, 17, MPI_CHAR, MPI_ANY_SOURCE, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            record_event(server_id, event_info);\n          }\n        }\n        MPI_Finalize();\n      }\n\n      This algorithm guarantees that all servers will have the same event history in the end. \n      It is important to notice that this algorithm is a simple solution for the case of n = 2, if the number of servers increases, it will not scale well, and other more robust algorithms should be applied.\n      ',read:!1},{id:3,name:"Jan-Feb 2017 Subject No.2",index:"Problem 1",question:"Write a parallel (distributed or local, at your choice) program for finding a Hamiltonian path starting at a given vertex. \n      That is, you are given a graph with n vertices and must find a path that starts at vertex 0 and goes through each of the other vertices exactly once. Find a solution, if one exits. \n      If needed, assume you have a function that gets a vector containing a permutation of length n and verifies if it is Hamiltonian path in the given graph or not.",answer:'\n      #include <mpi.h>\n      #include <vector>\n\n      int n; // number of vertices\n      std::vector<std::vector<int>> graph; // adjacency matrix representation of the graph\n      std::vector<int> path // to store the found Hamiltonian path\n\n      void search(int vertex, std::vector<bool> visited) {\n        // base case: if all vertices have been visited\n        if (path.size() == n) {\n          // check if the path is Hamiltonian\n          if (isHamiltonian(path)) {\n            // print the found path\n            for (int v : path) {\n              printf("%d ", v);\n            }\n            printf("\n");\n            MPI_Abort(MPI_COMM_WORLD, 1); // terminate all processes\n          }\n          return;\n        }\n        visted[vertex] = true;\n        path.push_back(vertex);\n        // recursively search for the next vertex\n        for (int i =0; i < n; i++) {\n          if (graph[vertex][i] && !visited[i]) {\n            search(i, visited);\n          }\n        }\n        visited[vertex] = false;\n        path.pop_back();\n      }\n\n      int main(int argc, char** argv) {\n        MPI_Init(&argc, &argv);\n        int rank, size;\n        MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n        MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n        // Read the graph\n        // ....\n\n        std::vector<bool> visited(n, false);\n        search(0, visited);\n\n        MPI_Finalize();\n        return 0;\n      }\n\n      We use a depth-first search to find a Hamiltonian path, starting from vertex 0. The function isHamiltonian is used to check if the path is valid, and it is already implemented.\n      We also use MPI to parallelize the search process. Each process starts the search from a different vertex and perform the search in parallel. Once a Hamiltonian path\n      is found, the search is terminated by calling \'MPI_Abort\' to terminate all processes.\n      ',read:!1},{id:4,name:"Jan-Feb 2017 Subject No.2",index:"Problem 2",question:"\n      Consider the following code for transferring money from one account to another. \n      You are required to write a function parsing all accounts (assume you have a vector <Account>) and compute the total amount of money there, so that it doesn't interfere with possible transfers at the same time. \n      Change the transfer function if needed, but it must be able to be called concurrently for independent pair of accounts.\n      ",answer:"\n      struct Account {\n        unsigned id;\n        unsigned balance;\n        mutex mtx;\n      };\n      \n      bool transfer(Account& from, Account& to, unsigned amount) {\n        {\n          unique_lock<mutex> lck1(from.mtx);\n          if(from.balance < amount) return false\n          from.balance -= amount;\n        }\n        {\n          unique_lock<mutex> lck2(to.mtx);\n          to.balance += amount;\n        }\n      }\n\n      Answer:\n\n      The current implementation is using unique locks which allows only one thread to access the critical section at a time. However, this is not enough to ensure that the transfer\n      function can be called concurrently for independent pairs of accounts, beacause both locks are on the same mutex. To avoid deadlocks, you need to lock the mutexes in a fixed\n      order to ensure the same pair of accounts always locks their mutexes in the same order.\n\n      Here's the updated code:\n\n      bool transfer(Account& from, Account& to, unsigned amount) {\n        Acount* accounts[] = {&from, &to};\n        sort(accounts, accounts+2, [](const Account* a, const Account* b) { return a->id < b->id; });\n        unique_lock<mutex> lck1(accounts[0]->mtx, defer_lock);\n        unique_lock<mutex> lck2(accounts[1]->mtx, defer_lock);\n        lock(lck1, lck2);\n        if(from.balance < amount) return false;\n        from.balance -= amount;\n        to.balance += amount;\n        return true;\n      }\n\n      The 'lock' function locks the two mutexes in the correct order and the 'defer_lock' option is used to prevent the lock from being acquired immediately, so that the lock order can be determined dynamically.\n      ",read:!1},{id:5,name:"Jan-Feb 2017 Subject No. 2",index:"Problem 3",question:"We have n servers that can communicate to each other. There are events producing on each of them; each event has an associated information. Each server must write a history of all events (server and event inio) produced on all servers, and, furthermore, the recorded history must be the same for all servers. Write a distributed algorithm that accomplishes that. Consider the case n = 2 for starting.",answer:"\n      Solution\n        Let's consider the case when n = 2. Let's name the processes A and B.\n\n        Every process will keep a Lamport clock and pass that on each message.\n\n        Suppose an event occurs in the process A. Then, process A will increate it's timestamp t by one, and send that event alongside t at the process B - this is called PREPARE event. Process B computes the maximum between its internal clock and the timestamp of the message and adds one. It send back an OK with that computed timestamp. Process A receives the OK and sends back a COMMIT message. They both agreed on this value.\n\n        The generalization to n > 2 follows easily.\n\n        Each process having an occuring event will:\n\n        broadcast PREPARE with the timestamp\n        waits for OKs from all the other processes\n        computes the maximum amongs the OKs timestamps\n        broadcast COMMIT to each process\n        There is only one little problem. A process may have previously gave an OK but did not get any COMMIT yet for that event. So, in case another COMMIT appears, it can't write that to a file because the COMMIT from the previously sent OK may be either before, or after the current COMMIT. That's why, each process will maintain a list of given OKs as well as a list of COMMITs to be flushed to disk.\n\n        Note. Every tie can be solved by chosing an initial arbitrary ordering of the processes. Such as the PID or IP if they live on different hosts.\n\n        Side note: Also, check out the solution on the Subject No.1, because they have the exact same question.\n      ",read:!1},{id:6,name:"Feb 2018 Subject No.1",index:"Problem 1",question:"\n      Write a parallel or distributed program that counts the number of permutations of N that satisfy a given property. \n      You have a function (bool pred(vector <int> const& v)) that verifies if a given permutation satisfies the property. \n      Your program shall call that function once for each permutation and count the number of times it returns true.\n      ",answer:"\n      This problem is solved using a parallel program in C++.\n\n      #include <iostream>\n      #include <thread>\n      #include <vector>\n      #include <atomic>\n\n      using namespace std;\n\n      bool check(vector<int> v) {\n        return (v[0] % 2 == 0);\n      }\n\n      bool contains(vector<int> v, int n) {\n        for (auto it: v) {\n          if(it == n) { return true; };\n        }\n        return false;\n      }\n\n      atomic <int> cnt;\n\n      void back(vector<int> sol, int T, int n) {\n        if(sol.size() == n) {\n          if(check(sol)) {\n            cnt++;\n          }\n          return;\n        }\n        if(T == 1) {\n          for(int i=1; i<=n; ++i) {\n            if(contains(sol, i)) continue;\n            sol.push_back(i);\n            back(sol, T, n);\n            sol.pop_back();\n          }\n        } else {\n          vector<int> x(sol);\n          thread t([&]() {\n            for(int i=1; i<=n; i+=2) {\n              if(contains(x, i)) continue;\n              x.push_back(i);\n              back(x, T/2, n);\n              x.pop_back();\n            }\n          });\n          for(int i=2; i<=n; i += 2) {\n            if(contains(sol, i)) continue;\n            x.push_back(i);\n            back(sol, T / 2, n);\n            sol.pop_back();\n          }\n          t.join();\n        }\n      }\n\n      int main() {\n        back(vector<int>(), 2, 3);\n        cout << cnt.load();\n      }\n      ",read:!1},{id:7,name:"Feb 2018 Subject No.1",index:"Problem 2",question:"\n      Consider the following code for a thread pool. Find the concurrency issue and fix it. Also, add a mechanism to end the threads at shutdown.\n      ",answer:"\n      class ThreadPool {\n        condition_variable cv;\n        mutex mtx;\n        list<function<void()>> work;\n        vector<thread> threads;\n      \n        void run() {\n          unique_lock<mutex> lck(mtx);\n          while(true) {\n            if(work.empty()) {\n             cv.wait(lck);\n           } else {\n             function<void()> vi = work.front();\n             work.pop_front();\n             vi();\n           }\n         }\n       }\n      \n      public:\n        explicit ThreadPool(int n) {\n          threads.resize(n);\n          for(int i=0; i<n; ++i) {\n            threads.emplace_back([this]() { run(); });\n          }\n        }\n        void enqueue(function<void()> f) {\n          unique_lock<mutex> lck(mtx);\n          work.push_back(f);\n          cv.notify_one();\n        }\n      };\n\n      Answer:\n\n      class ThreadPool {\n        condition_variable cv;\n        mutex mtx;\n        list<function<void()>> work;\n        vector<thread> threads;\n        bool done = false;\n      \n        void run() {\n          unique_lock<mutex> lck(mtx);\n          while(!done) {\n            if(work.empty()) {\n              cv.wait(lck);\n            } else {\n              function<void()> vi = work.front();\n              work.pop_front();\n              lck.unlock();\n              vi();\n              lck.lock();\n            }\n          }\n        }\n      \n      public:\n        explicit ThreadPool(int n) {\n          threads.resize(n);\n          for(int i=0; i<n; ++i) {\n            threads.emplace_back([this]() { run(); });\n          }\n        }\n        ~ThreadPool() {\n          unique_lock<mutex> lck(mtx);\n          done = true;\n          cv.notify_all();\n          lck.unlock();\n          for(thread& t : threads) {\n            t.join();\n          }\n        }\n        void enqueue(function<void()> f) {\n          unique_lock<mutex> lck(mtx);\n          work.push_back(f);\n          cv.notify_one();\n        }\n      };\n      - Added a variable done to signal the threads to stop running when the thread pool is destroyed.\n      - Used !done instead of true in the while loop to stop the threads when the thread pool is destroyed.\n      - Released the lock in run before calling the task to avoid deadlocks.\n      - Added a destructor to properly shut down the threads.\n      ",read:!1},{id:8,name:"Feb 2018 Subject No.1",index:"Problem 3",question:"\n      Write a parallel or distributed program that finds all the prime numbers up to N. Hint: serially produce all the prime numbers up to sqrt(N), and distribute\n      them to all threads or processes.\n      ",answer:'\n      public class PrimeFinderThreads {\n        private static final int N = 10000;\n        private static final int sqrtN = (int) Math.sqrt(N);\n        private static final AtomicInteger count = new AtomicInteger();\n    \n        private static final int numThreads = 24;\n    \n        public void startThreads() {\n            Thread[] threads = new Thread[numThreads];\n            int chunk = N / numThreads;\n    \n            for (int i = 0; i < numThreads; i++) {\n    \n                int start = i * chunk;\n                int end;\n                if (i == numThreads - 1) {\n                    end = N;\n                } else {\n                    end = (i + 1) * chunk - 1;\n                }\n                System.out.println("start = " + start + "; end = " + end);\n                threads[i] = new Thread(() -> {\n                    for (int j = start; j <= end; j++) {\n                        if (isPrime(j)) {\n                            count.incrementAndGet();\n                        }\n                    }\n                });\n                threads[i].start();\n            }\n    \n            for (int i = 0; i < numThreads; i++) {\n                try {\n                    threads[i].join();\n                } catch (InterruptedException e) {\n                    System.out.println("Thread interrupted: " + e.getMessage());\n                }\n            }\n    \n            System.out.println("Number of primes up to sqrt(" + N + "): " + count.get());\n        }\n    \n          private static boolean isPrime(int n) {\n              if (n <= 1) return false;\n              if (n == 2) return true;\n              if (n % 2 == 0) return false;\n              int k = 3;\n              while (k * k <= n && n % k != 0) {\n                  k += 2;\n              }\n              return k * k > n;\n          }\n      }\n      ',read:!1},{id:9,name:"Feb 2018 Subject No.2",index:"Problem 1",question:"\n      Write a parallel (distributed or local, at your choice) program that computes the (discrete) convolution of a vector with another vector. \n      The convolution is defined as ri=(sum from j=0 to N-1)aj bi-j. All three vectors are of length N and, for simplicity, i - j shall be taken modulo N.\n      ",answer:'\n      Here is an example implementation in C++ using MPI:\n\n      #include <mpi.h>\n      #include <vector>\n      #include <cmath>\n      #include <iostream>\n\n      const int N = 100; // Length of vectors\n\n      // Compute the convolution of two vectors using MPI\n      std::vector<double> convolution(const std::vector<double> &a, const std::vector<double> &b) {\n        int size, rank;\n        MPI_Comm_size(MPI_COMM_WORLD, &size);\n        MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n        int chunk_size = ceil(N / size);\n        int start = rank * chunk_size;\n        int end = start + chunk_size;\n        end = std::min(end, N);\n\n        std::vector<double> result(N);\n        for (int i = start; i < end; i++) {\n          result[i] = 0.0;\n          for (int j = 0; j < N; j++) {\n          result[i] += a[j] * b[(i - j + N) % N];\n        }\n      }\n\n        std::vector<double> final_result(N);\n        MPI_Allreduce(result.data(), final_result.data(), N, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n        return final_result;\n      }\n\n      int main(int argc, char *argv[]) {\n        MPI_Init(&argc, &argv);\n\n        std::vector<double> a(N);\n        std::vector<double> b(N);\n\n        // Fill the vectors a and b with values\n        // ...\n\n        auto result = convolution(a, b);\n\n        if (rank == 0) {\n          std::cout << "Result of convolution: ";\n          for (auto r : result) {\n            std::cout << r << " ";\n          }\n          std::cout << std::endl;\n        }\n\n        MPI_Finalize();\n        return 0;\n      }\n      ',read:!1},{id:10,name:"Feb 2018 Subject No.2",index:"Problem 2",question:"\n      Consider the following code for enqueueing a continuation on a future. Identify and fix the thread-safety issue.\n      ",answer:"\n      template<typename T> class Future {\n        list<function<void (T)>> continuations;\n        T val;\n        bool hasValue;\n      public:\n        Future() hasValue(false) {}\n        void set (T v) {\n          val = V;\n          hasValue = true;\n          for (function<void (T)>& f: continuations) {\n            f(v);\n          }\n          continuations.clear();\n        }\n      \n        void addContinuation (function<void (T)> f) { \n          if (hasValue) {\n            f(val);\n          } else {\n            continuations.push_back(f);\n          }\n        }\n      };\n\n      Answer:\n\n      The thread-safety issue in the code is that the set method and the addContinuation method are not protected by a synchronization mechanism. If one thread is setting the value of the future while another thread is enqueueing a continuation, it's possible for the continuation to be executed before the value has been set, which could result in incorrect behavior.\n      To fix this, we need to ensure that access to the val variable, hasValue flag, and the continuations list is synchronized across multiple threads. We can use a mutex to ensure that access to these shared resources is mutually exclusive.\n\n      template<typename T> class Future {\n        list<function<void (T)>> continuations;\n        T val;\n        bool hasValue;\n        mutex mtx;\n        \n      public:\n        Future() hasValue(false) {}\n        void set (T v) {\n          unique_lock<mutex> lck(mtx);\n          val = V;\n          hasValue = true;\n          for (function<void (T)>& f: continuations) {\n            f(v);\n          }\n          continuations.clear();\n        }\n        \n        void addContinuation (function<void (T)> f) {\n          unique_lock<mutex> lck(mtx);\n          if (hasValue) {\n            f(val);\n          } else {\n            continuations.push_back(f);\n          }\n          }\n        };\n      ",read:!1},{id:11,name:"Feb 2018 Subject No.2",index:"Problem 3",question:"Write a parallel algorithm that computes the product of 2 matrices.",answer:'\n      public class MatrixMultiplication {\n\n        private static final int N = 1000; // matrix dimension\n    \n        public final int[][] A = new int[N][N];\n        public final int[][] B = new int[N][N];\n        private static final int[][] result = new int[N][N];\n    \n        private static final int[][] result2 = new int[N][N];\n    \n        private static final int NUM_THREADS = 23;\n    \n        private class MultiplyTask implements Runnable {\n            private final int startRow;\n            private final int endRow;\n    \n            public MultiplyTask(int _startRow, int _endRow) {\n                startRow = _startRow;\n                endRow = _endRow;\n            }\n    \n            @Override\n            public void run() {\n                for (int i = startRow; i < endRow; i ++) {\n                    for (int j = 0; j < N; j ++) {\n                        result[i][j] += A[i][j] * B[i][j];\n                    }\n                }\n            }\n        }\n    \n          private void initMatrices() {\n              Random random = new Random();\n              for (int i = 0; i < N; i ++) {\n                  for (int j = 0; j < N; j ++) {\n                      A[i][j] = random.nextInt(10);\n                      B[i][j] = random.nextInt(10);\n                  }\n              }\n          }\n      \n          private void computeIterative() {\n              for (int i = 0; i < N; i ++) {\n                  for (int j = 0; j < N; j ++) {\n                      result2[i][j] += A[i][j] * B[i][j];\n                  }\n              }\n          }\n      \n          private boolean correctnessCheck() {\n              for (int i = 0; i < N; i ++) {\n                  for (int j = 0; j < N; j ++) {\n                      if (result[i][j] != result2[i][j]) {\n                          return false;\n                      }\n                  }\n              }\n              return true;\n          }\n      \n          public void startThreads() {\n              initMatrices();\n              Thread[] threads = new Thread[NUM_THREADS];\n              int k = N / NUM_THREADS;\n      \n              for (int i = 0; i < NUM_THREADS; i ++) {\n                  int startRow = i * k;\n                  int endRow;\n                  if (i == NUM_THREADS - 1) {\n                      endRow = N;\n                  } else {\n                      endRow = (i + 1) * k;\n                  }\n      \n                  threads[i] = new Thread(new MultiplyTask(startRow, endRow));\n                  threads[i].start();\n              }\n      \n              for (int i = 0; i < NUM_THREADS; i ++) {\n                  try {\n                      threads[i].join();\n                  } catch (InterruptedException e) {\n                      throw new RuntimeException(e);\n                  }\n              }\n      \n              var s = new StringBuilder();\n              for (int i = 0; i < N; i ++) {\n                  for (int j = 0; j < N; j ++) {\n                      s.append(result[i][j]).append(" ");\n                  }\n                  s.append("newline");\n              }\n              System.out.println(s);\n      \n              computeIterative();\n              var flag = correctnessCheck();\n              System.out.println(flag);\n          }\n      }\n      ',read:!1},{id:12,name:"Feb 2018 Subject No.3",index:"Problem 1",question:"\n      Write a parallel or distributed program that counts the number of permutations of N that satisfy a given property. \n      You have a function bool pred (vector<int> const& v) that verifies if a given permutation satisfies the property. \n      Your program shall call that function once for each permutation and count the number of times it returns true. \n      ",answer:"\n      #include <mpi.h>\n      #include <iostream>\n      #include <vector>\n      #include <algorithm>\n\n      using namespace std;\n\n      const int root = 0;\n      bool pred(vector<int> const& v);\n\n      int main(int argc, char *argv[]) {\n        MPI_Init(&argc, &argv);\n\n        int world_size, rank;\n        MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n        MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n        int N;\n        if (rank == root) {\n          cin >> N;\n        }\n        MPI_Bcast(&N, 1, MPI_INT, root, MPI_COMM_WORLD);\n\n        vector<int> perm(N);\n        for (int i = 0; i < N; i++) {\n          perm[i] = i;\n        }\n\n        int count = 0;\n        int chunk_size = N / world_size;\n        int start = chunk_size * rank;\n        int end = start + chunk_size;\n        if (rank == world_size - 1) {\n          end = N;\n        }\n\n        do {\n          for (int i = start; i < end; i++) {\n            vector<int> subperm(perm.begin(), perm.begin() + i + 1);\n            if (pred(subperm)) {\n              count++;\n            }\n          }\n        } while (next_permutation(perm.begin(), perm.end()));\n\n        int total_count = 0;\n        MPI_Reduce(&count, &total_count, 1, MPI_INT, MPI_SUM, root, MPI_COMM_WORLD);\n\n        if (rank == root) {\n          cout << total_count << endl;\n        }\n\n        MPI_Finalize();\n        return 0;\n      }\n\n      bool pred(vector<int> const& v) {\n        // Your code to check if the permutation satisfies the property\n        return true;\n      } \n      ",read:!1},{id:13,name:"Feb 2018 Subject No.3",index:"Problem 2",question:"Consider the following code for enqueueing a work item to a thread pool. Find the concurrency issue and fix it. Also, add a mechanism to end the threads at shutdown.",answer:'\n      class ThreadPool {\n        condition_variable cv;\n        mutex mtx;\n        list<function<void()>> work; \n        vector<thread> threads;\n        void run() {\n          while(true) {\n            if (work.empty()) {\n              unique_lock<mutex> lck(mtx); \n              cv.wait(lck);\n            } else {\n              function<void()> vi = work.front(); \n              work.pop_front();\n              wi();\n            }\n          }\n        }\n      public:\n        explicit ThreadPool (int n) {\n          threads.resize(n);\n          for(int i=0; i<n; ++i) {\n            threads.emplace_back([this] () {run();});\n          }\n        }\n        void enqueue (function<void()> f) {\n          unique_lock<mutex> lck (mtx):\n          work.push_back(f);\n          cv.notify_one();\n        }\n      }\n\n      Answer:\n\n      The code is trying to create a thread pool, where a user can enqueue work items that will be executed by the pool threads.\n\n      Concurrency issue:\n\n      The code does not have any mechanism to end the threads at shutdown, which could result in memory leaks or resource starvation.\n      Fix:\n\n      To fix the issue, you can add a flag variable named "done" that is used to indicate the threads to shut down.\n      At shutdown, the flag can be set to true and broadcasted to all threads using cv.notify_all().\n      In the run function, you can check the value of the done flag and exit the loop when it is true.\n\n      class ThreadPool {\n        condition_variable cv;\n        mutex mtx;\n        list<function<void()>> work; \n        vector<thread> threads;\n        bool done = false;\n        void run() {\n          while(true) {\n            if (work.empty() && !done) {\n              unique_lock<mutex> lck(mtx); \n              cv.wait(lck);\n            } else if (done) {\n              break;\n            } else {\n              function<void()> vi = work.front(); \n              work.pop_front();\n              wi();\n            }\n          }\n        }\n      public:\n        explicit ThreadPool (int n) {\n          threads.resize(n);\n          for(int i=0; i<n; ++i) {\n            threads.emplace_back([this] () {run();});\n          }\n        }\n        void enqueue (function<void()> f) {\n          unique_lock<mutex> lck (mtx):\n          work.push_back(f);\n          cv.notify_one();\n        }\n        void shutdown() {\n          {\n            unique_lock<mutex> lck (mtx);\n            done = true;\n          }\n          cv.notify_all();\n          for (auto& t : threads) {\n            t.join();\n          }\n        }\n      }\n      ',read:!1},{id:14,name:"Feb 2018 Subject No.3",index:"Problem 3",question:"Write a parallel algorithm that computes the product of two big numbers.",answer:'\n      import java.math.BigInteger;\n      import java.util.concurrent.Callable;\n      import java.util.concurrent.ExecutorService;\n      import java.util.concurrent.Executors;\n      import java.util.concurrent.Future;\n\n      public class BigNumberProduct {\n          static class Multiplier implements Callable<BigInteger> {\n              BigInteger num1;\n              BigInteger num2;\n\n              Multiplier(BigInteger num1, BigInteger num2) {\n                  this.num1 = num1;\n                  this.num2 = num2;\n              }\n\n              @Override\n              public BigInteger call() {\n                  return num1.multiply(num2);\n              }\n          }\n\n          public static void main(String[] args) throws Exception {\n              BigInteger num1 = new BigInteger("1234567890123456789012345678901234567890");\n              BigInteger num2 = new BigInteger("9876543210987654321098765432109876543210");\n              int numThreads = 4;\n              ExecutorService executor = Executors.newFixedThreadPool(numThreads);\n              Future<BigInteger>[] futures = new Future[numThreads];\n              for (int i = 0; i < numThreads; i++) {\n                  BigInteger subNum1 = num1.divide(BigInteger.valueOf(numThreads)).multiply(BigInteger.valueOf(i));\n                  BigInteger subNum2 = num2.divide(BigInteger.valueOf(numThreads)).multiply(BigInteger.valueOf(i));\n                  futures[i] = executor.submit(new Multiplier(subNum1, subNum2));\n              }\n              BigInteger product = BigInteger.ZERO;\n              for (int i = 0; i < numThreads; i++) {\n                  product = product.add(futures[i].get());\n              }\n              executor.shutdown();\n              System.out.println("Product: " + product);\n          }\n      }\n      ',read:!1}],this.subjectsFrom2017=[this.exercises[0],this.exercises[1],this.exercises[2],this.exercises[3],this.exercises[4],this.exercises[5]],this.subjectsFrom2018=[this.exercises[6],this.exercises[7],this.exercises[8],this.exercises[9],this.exercises[10],this.exercises[11],this.exercises[12],this.exercises[13],this.exercises[14]]}getExercisesByYear(t){switch(t){case 2017:return this.subjectsFrom2017;case 2018:return this.subjectsFrom2018;default:return this.exercises}}getExerciseById(t){return this.exercises[t]}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=o.Yz7({token:e,factory:e.\u0275fac,providedIn:"root"}),e})()}}]);